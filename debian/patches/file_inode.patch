--- a/scst/src/scst_lib.c
+++ b/scst/src/scst_lib.c
@@ -10371,7 +10371,7 @@
 		goto out_close;
 	}
 
-	inode = file_src->f_dentry->d_inode;
+	inode = file_inode(file_src);
 
 	if (S_ISREG(inode->i_mode))
 		/* Nothing to do */;
@@ -10588,7 +10588,7 @@
 		goto out;
 	}
 
-	inode = file->f_dentry->d_inode;
+	inode = file_inode(file);
 
 	if (S_ISREG(inode->i_mode))
 		/* Nothing to do */;
@@ -10673,7 +10673,7 @@
 		res = PTR_ERR(file);
 		goto out;
 	}
-	res = file->f_dentry->d_inode->i_mode;
+	res = file_inode(file);
 	filp_close(file, NULL);
 
 out:
--- a/scst/src/scst_pres.c
+++ b/scst/src/scst_pres.c
@@ -682,7 +682,7 @@
 		goto out;
 	}
 
-	inode = file->f_dentry->d_inode;
+	inode = file_inode(file);
 
 	if (S_ISREG(inode->i_mode))
 		/* Nothing to do */;
--- a/scst/src/dev_handlers/scst_vdisk.c
+++ b/scst/src/dev_handlers/scst_vdisk.c
@@ -864,7 +864,7 @@
 		goto out;
 	}
 
-	inode = fd->f_dentry->d_inode;
+	inode = file_inode(fd);
 
 	if (!S_ISBLK(inode->i_mode)) {
 		PRINT_ERROR("%s is NOT a block device", virt_dev->filename);
@@ -890,6 +890,7 @@
 {
 	struct file *fd = NULL;
 	bool fd_open = false;
+	struct inode *inode = file_inode(fd);
 
 	TRACE_ENTRY();
 
@@ -907,7 +908,6 @@
 	fd_open = true;
 
 	if (virt_dev->blockio) {
-		struct inode *inode = fd->f_dentry->d_inode;
 		if (!S_ISBLK(inode->i_mode)) {
 			PRINT_ERROR("%s is NOT a block device",
 				virt_dev->filename);
@@ -946,7 +946,7 @@
 		if (virt_dev->blockio) {
 			struct request_queue *q;
 			sBUG_ON(!fd_open);
-			q = bdev_get_queue(fd->f_dentry->d_inode->i_bdev);
+			q = bdev_get_queue(inode->i_bdev);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32) || \
 	(defined(RHEL_MAJOR) && RHEL_MAJOR -0 >= 6)
 			virt_dev->unmap_opt_gran = q->limits.discard_granularity >> block_shift;
@@ -1005,7 +1005,7 @@
 		goto out;
 	}
 
-	inode = fd->f_dentry->d_inode;
+	inode = file_inode(fd);
 
 	if (blockio && !S_ISBLK(inode->i_mode)) {
 		PRINT_ERROR("File %s is NOT a block device", filename);
@@ -1453,6 +1453,7 @@
 static int vdisk_open_fd(struct scst_vdisk_dev *virt_dev, bool read_only)
 {
 	int res;
+	struct inode *inode;
 
 	lockdep_assert_held(&scst_mutex);
 	sBUG_ON(!virt_dev->filename);
@@ -1465,8 +1466,9 @@
 			    virt_dev->filename, res);
 		goto out;
 	}
+	inode = file_inode(virt_dev->fd);
 	virt_dev->bdev = virt_dev->blockio ?
-		virt_dev->fd->f_dentry->d_inode->i_bdev : NULL;
+		inode->i_bdev : NULL;
 	res = 0;
 
 out:
@@ -3089,7 +3091,7 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27)
 		sector_t start_sector = start_lba << (cmd->dev->block_shift - 9);
 		sector_t nr_sects = blocks << (cmd->dev->block_shift - 9);
-		struct inode *inode = fd->f_dentry->d_inode;
+		struct inode *inode = file_inode(fd);
 		gfp_t gfp = cmd->cmd_gfp_mask;
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 31)
 		err = blkdev_issue_discard(inode->i_bdev, start_sector, nr_sects, gfp);
@@ -4770,7 +4772,7 @@
 	file = virt_dev->fd;
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
-	res = sync_page_range(file->f_dentry->d_inode, file->f_mapping,
+	res = sync_page_range(file_inode(file), file->f_mapping,
 		loff, len);
 #else
 #if 0	/* For sparse files we might need to sync metadata as well */
